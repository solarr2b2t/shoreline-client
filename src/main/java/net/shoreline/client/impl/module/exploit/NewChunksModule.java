package net.shoreline.client.impl.module.exploit;

import com.google.common.collect.Sets;
import io.netty.buffer.Unpooled;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.block.entity.MobSpawnerBlockEntity;
import net.minecraft.network.PacketByteBuf;
import net.minecraft.network.packet.s2c.play.ChunkDataS2CPacket;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.world.World;
import net.minecraft.world.chunk.ChunkSection;
import net.minecraft.world.chunk.PalettedContainer;
import net.minecraft.world.chunk.WorldChunk;
import net.shoreline.client.api.config.Config;
import net.shoreline.client.api.config.setting.BooleanConfig;
import net.shoreline.client.api.config.setting.ColorConfig;
import net.shoreline.client.api.config.setting.NumberConfig;
import net.shoreline.client.api.module.ModuleCategory;
import net.shoreline.client.api.module.ToggleModule;
import net.shoreline.client.api.render.RenderBuffers;
import net.shoreline.client.api.render.RenderManager;
import net.shoreline.client.impl.event.TickEvent;
import net.shoreline.client.impl.event.network.GameJoinEvent;
import net.shoreline.client.impl.event.network.PacketEvent;
import net.shoreline.client.impl.event.render.RenderWorldEvent;
import net.shoreline.client.util.chat.ChatUtil;
import net.shoreline.client.util.render.ColorUtil;
import net.shoreline.client.util.world.BlockUtil;
import net.shoreline.eventbus.annotation.EventListener;
import net.shoreline.eventbus.event.StageEvent;

import java.awt.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * @author linus
 * @since 1.0
 */
public class NewChunksModule extends ToggleModule
{
    Config<Boolean> newChunksConfig = register(new BooleanConfig("NewChunks", "Shows new chunks", true));
    Config<Boolean> oldChunksConfig = register(new BooleanConfig("OldChunks", "Shows old chunks", false));
    Config<Integer> yLevelConfig = register(new NumberConfig<>("YLevel", "The rendering y level", -64, 0, 256));
    Config<Color> newChunksColorConfig = register(new ColorConfig("NewChunksColor", "The color for rendering new chunks", Color.GREEN, false, true, () -> newChunksConfig.getValue()));
    Config<Color> oldChunksColorConfig = register(new ColorConfig("OldChunksColor", "The color for rendering old chunks", Color.RED, false, false, () -> oldChunksConfig.getValue()));

    Config<Boolean> spawnerDetectorConfig = register(new BooleanConfig("SpawnerDetector", "Shows activated spawners", false));
    Config<Boolean> rangeConfig = register(new BooleanConfig("SpawnerRange", "Show spawner range", true));
    Config<Boolean> notifyConfig = register(new BooleanConfig("Notify", "Notify in chat when an activated spawner is found", true, () -> false));
    Config<Color> colorConfig = register(new ColorConfig("SpawnerColor", "The color of the tracked spawners", Color.MAGENTA, false, false));

    private final Set<ChunkPos> newChunks = Sets.newConcurrentHashSet();
    private final Set<ChunkPos> oldChunks = Sets.newConcurrentHashSet();

    private final List<BlockPos> activatedSpawners = new ArrayList<>();

    public NewChunksModule()
    {
        super("NewChunks", "Highlights chunks that have been recently generated", ModuleCategory.EXPLOITS);
    }

    @Override
    public void onDisable()
    {
        activatedSpawners.clear();
    }

    @EventListener
    public void onGameJoin(GameJoinEvent event)
    {
        newChunks.clear();
        oldChunks.clear();
    }

    @EventListener
    public void onTick(TickEvent event)
    {
        if (event.getStage() != StageEvent.EventStage.PRE)
        {
            return;
        }

        for (BlockEntity block : BlockUtil.blockEntities())
        {
            if (!(block instanceof MobSpawnerBlockEntity spawner) || spawner.getLogic().spawnDelay == 20)
            {
                continue;
            }
            if (mc.world.getRegistryKey() == World.NETHER && spawner.getLogic().spawnDelay == 0)
            {
                continue;
            }

            BlockPos blockPos = spawner.getPos();
            if (activatedSpawners.contains(blockPos))
            {
                continue;
            }

            // Check for nearby chests
            for (int x = -16; x < 17; x++)
            {
                for (int y = -16; y < 17; y++)
                {
                    for (int z = -16; z < 17; z++)
                    {
                        BlockPos bpos = new BlockPos(blockPos.getX() + x,blockPos.getY() + y,blockPos.getZ() + z);
                        if (mc.world.getBlockState(bpos).getBlock() == Blocks.CHEST)
                        {
                            activatedSpawners.add(blockPos);
                            if (notifyConfig.getValue())
                            {
                                ChatUtil.clientSendMessageRaw(String.format("§s[%s]§f Located activated spawner at %s!", name, blockPos.toShortString()), blockPos.hashCode());
                            }
                            break;
                        }
                    }
                }
            }
        }

        BlockPos cameraPos = mc.getCameraEntity().getBlockPos();
        double renderDistanceBlocks = mc.options.getViewDistance().getValue() * 16;
        activatedSpawners.removeIf(chunkPos -> !cameraPos.isWithinDistance(chunkPos, renderDistanceBlocks));
    }

    @EventListener
    public void onRenderWorld(RenderWorldEvent event)
    {
        RenderBuffers.preRender();
        if (newChunksConfig.getValue())
        {
            for (ChunkPos chunkPos : newChunks)
            {
                RenderManager.renderBoundingBox(event.getMatrices(), new Box(chunkPos.getStartX(), yLevelConfig.getValue(), chunkPos.getStartZ(), chunkPos.getEndX() + 1.0, yLevelConfig.getValue(), chunkPos.getEndZ() + 1.0), 1.5f, newChunksColorConfig.getValue().getRGB());
            }
        }
        if (oldChunksConfig.getValue())
        {
            for (ChunkPos chunkPos : oldChunks)
            {
                RenderManager.renderBoundingBox(event.getMatrices(), new Box(chunkPos.getStartX(), yLevelConfig.getValue(), chunkPos.getStartZ(), chunkPos.getEndX() + 1.0, yLevelConfig.getValue(), chunkPos.getEndZ() + 1.0), 1.5f, oldChunksColorConfig.getValue().getRGB());
            }
        }

        if (spawnerDetectorConfig.getValue())
        {
            for (BlockPos blockPos : activatedSpawners)
            {
                RenderManager.renderBox(event.getMatrices(), blockPos, ColorUtil.withAlpha(colorConfig.getValue().getRGB(), 70));
                RenderManager.renderBoundingBox(event.getMatrices(), blockPos, 1.5f, ColorUtil.withAlpha(colorConfig.getValue().getRGB(), 145));

                if (rangeConfig.getValue())
                {
                    RenderManager.renderBoundingBox(event.getMatrices(), new Box(blockPos).expand(4.0), 1.5f, colorConfig.getValue().getRGB());
                }
            }
        }
        RenderBuffers.postRender();
    }

    @EventListener
    public void onPacketInbound(PacketEvent.Inbound event)
    {
        if (mc.world == null)
        {
            return;
        }
        if (event.getPacket() instanceof ChunkDataS2CPacket packet)
        {
            ChunkPos chunkPos = new ChunkPos(packet.getChunkX(), packet.getChunkZ());
            WorldChunk chunk = new WorldChunk(mc.world, chunkPos);
            // https://github.com/etianl/Trouser-Streak/blob/main/src/main/java/pwn/noobs/trouserstreak/modules/NewerNewChunks.java
            // 99% accuracy
            PacketByteBuf buf = packet.getChunkData().getSectionsDataBuf();
            boolean isNewChunk = false;
            boolean firstchunkappearsnew = false;
            PacketByteBuf bufferCopy = new PacketByteBuf(Unpooled.copiedBuffer(buf.nioBuffer()));
            if (buf.readableBytes() < 3)
            {
                return;
            }

            buf.readShort();

            int blockBitsPerEntry = buf.readUnsignedByte();
            if (blockBitsPerEntry >= 4 && blockBitsPerEntry <= 8)
            {
                int blockPaletteLength = buf.readVarInt();
                int blockPaletteEntry = buf.readVarInt();
                if (blockPaletteEntry == 0 && mc.world.getRegistryKey() != World.END)
                {
                    firstchunkappearsnew = true;
                }
            }
            if (bufferCopy.readableBytes() < 2)
            {
                return;
            }

            int loops = 0;
            int newChunkQuantifier = 0;
            int oldChunkQuantifier = 0;
            try
            {
                while (bufferCopy.readableBytes() > 0 && loops < 8)
                {
                    short blockCount = bufferCopy.readShort();
                    if (bufferCopy.readableBytes() < 1)
                    {
                        break;
                    }
                    int blockBitsPerEntry2 = bufferCopy.readUnsignedByte();
                    if (blockBitsPerEntry2 == 0)
                    {
                        int singleBlockValue = bufferCopy.readVarInt();
                        bufferCopy.readVarInt();
                    }
                    else if (blockBitsPerEntry2 >= 4 && blockBitsPerEntry2 <= 8)
                    {
                        ChunkSection section = chunk.getSectionArray()[loops];
                        PalettedContainer<BlockState> palettedContainer = section.getBlockStateContainer();
                        Set<BlockState> bstates = new HashSet<>();
                        for (int x = 0; x < 16; x++)
                        {
                            for (int y = 0; y < 16; y++)
                            {
                                for (int z = 0; z < 16; z++)
                                {
                                    bstates.add(palettedContainer.get(x, y, z));
                                }
                            }
                        }
                        int blockPaletteLength = bufferCopy.readVarInt();
                        int isNewSection = 0;
                        int isOlderOldSection = 0;
                        int bstatesSize = bstates.size();
                        if (bstatesSize <= 1)
                        {
                            bstatesSize = blockPaletteLength;
                        }
                        if (bstatesSize < blockPaletteLength)
                        {
                            isNewSection = 2;
                            newChunkQuantifier++;
                        }
                        for (int i = 0; i < blockPaletteLength; i++)
                        {
                            int blockPaletteEntry = bufferCopy.readVarInt();
                            if (i == 0 && blockPaletteEntry == 0 && mc.world.getRegistryKey() == World.OVERWORLD)
                            {
                                isNewSection++;
                            }
                            if (i == 1 && (blockPaletteEntry == 80 || blockPaletteEntry == 1 || blockPaletteEntry == 9 || blockPaletteEntry == 5781) && mc.world.getRegistryKey() == World.OVERWORLD)
                            {
                                isNewSection++;
                            }
                            if (i == 2 && (blockPaletteEntry == 5781 || blockPaletteEntry == 10 || blockPaletteEntry == 22318) && mc.world.getRegistryKey() == World.OVERWORLD)
                            {
                                isNewSection++;
                            }
                            if (loops == 4 && blockPaletteEntry == 79 && mc.world.getRegistryKey() == World.OVERWORLD)
                            {
                                if (!oldChunks.contains(chunkPos) && !newChunks.contains(chunkPos))
                                {
                                    oldChunks.add(chunkPos);
                                    return;
                                }
                            }
                            if (blockPaletteEntry == 0 && mc.world.getRegistryKey() == World.NETHER | mc.world.getRegistryKey() == World.END)
                            {
                                isOlderOldSection++;
                            }
                        }
                        if (isOlderOldSection >= 2)
                        {
                            oldChunkQuantifier++;
                        }
                        if (isNewSection >= 2)
                        {
                            newChunkQuantifier++;
                        }

                        int blockDataArrayLength = bufferCopy.readVarInt();
                        if (bufferCopy.readableBytes() >= blockDataArrayLength * 8)
                        {
                            bufferCopy.skipBytes(blockDataArrayLength * 8);
                        }
                        else
                        {
                            bufferCopy.skipBytes(bufferCopy.readableBytes());
                            break;
                        }
                    }
                    else if (blockBitsPerEntry2 == 15)
                    {
                        int blockDataArrayLength = bufferCopy.readVarInt();
                        if (bufferCopy.readableBytes() >= blockDataArrayLength * 8)
                        {
                            bufferCopy.skipBytes(blockDataArrayLength * 8);
                        }
                        else
                        {
                            bufferCopy.skipBytes(bufferCopy.readableBytes());
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }

                    if (bufferCopy.readableBytes() < 1)
                    {
                        break;
                    }

                    int biomeBitsPerEntry = bufferCopy.readUnsignedByte();
                    if (biomeBitsPerEntry == 0)
                    {
                        int singleBiomeValue = bufferCopy.readVarInt();
                        if (singleBiomeValue == 39 && mc.world.getRegistryKey() == World.END)
                        {
                            isNewChunk = true;
                        }
                        bufferCopy.readVarInt();
                    }
                    else if (biomeBitsPerEntry >= 1 && biomeBitsPerEntry <= 3)
                    {
                        int biomePaletteLength = bufferCopy.readVarInt();
                        for (int i = 0; i < biomePaletteLength; i++)
                        {
                            if (bufferCopy.readableBytes() < 1)
                            {
                                break;
                            }
                            int biomePaletteEntry = bufferCopy.readVarInt();
                            if (i == 0 && biomePaletteEntry == 39 && mc.world.getRegistryKey() == World.END)
                            {
                                isNewChunk = true;
                            }
                        }
                        if (bufferCopy.readableBytes() >= 1)
                        {
                            int biomeDataArrayLength = bufferCopy.readVarInt();
                            if (bufferCopy.readableBytes() >= biomeDataArrayLength * 8)
                            {
                                bufferCopy.skipBytes(biomeDataArrayLength * 8);
                            }
                            else
                            {
                                bufferCopy.skipBytes(bufferCopy.readableBytes());
                                break;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    else if (biomeBitsPerEntry == 6)
                    {
                        int biomeDataArrayLength = bufferCopy.readVarInt();
                        if (bufferCopy.readableBytes() >= biomeDataArrayLength * 8)
                        {
                            bufferCopy.skipBytes(biomeDataArrayLength * 8);
                        }
                        else
                        {
                            bufferCopy.skipBytes(bufferCopy.readableBytes());
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                    loops++;
                }
                if (loops > 0)
                {
                    if (mc.world.getRegistryKey() == World.NETHER || mc.world.getRegistryKey() == World.END)
                    {
                        double oldpercentage = ((double) oldChunkQuantifier / loops) * 100;
                        if (oldpercentage >= 25)
                        {
                            isNewChunk = false;
                            if (!oldChunks.contains(chunkPos) && !newChunks.contains(chunkPos))
                            {
                                oldChunks.add(chunkPos);
                                return;
                            }
                        }
                    }
                    if (mc.world.getRegistryKey() == World.OVERWORLD)
                    {
                        double percentage = ((double) newChunkQuantifier / loops) * 100;
                        if (percentage >= 65)
                        {
                            isNewChunk = true;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                e.printStackTrace();
                if (mc.world.getRegistryKey() == World.NETHER || mc.world.getRegistryKey() == World.END)
                {
                    double oldpercentage = ((double) oldChunkQuantifier / loops) * 100;
                    if (oldpercentage >= 25)
                    {
                        isNewChunk = false;
                        if (!oldChunks.contains(chunkPos) && !newChunks.contains(chunkPos))
                        {
                            oldChunks.add(chunkPos);
                            return;
                        }
                    }
                }
                if (mc.world.getRegistryKey() == World.OVERWORLD)
                {
                    double percentage = ((double) newChunkQuantifier / loops) * 100;
                    if (percentage >= 65)
                    {
                        isNewChunk = true;
                    }
                }
            }

            if (firstchunkappearsnew)
            {
                isNewChunk = true;
            }
            if (!isNewChunk)
            {
                try
                {
                    if (!oldChunks.contains(chunkPos) && !newChunks.contains(chunkPos))
                    {
                        oldChunks.add(chunkPos);
                    }
                }
                catch (Exception e)
                {
                    //e.printStackTrace();
                }
            }
            else
            {
                try
                {
                    if (!oldChunks.contains(chunkPos) && !newChunks.contains(chunkPos))
                    {
                        newChunks.add(chunkPos);
                    }
                }
                catch (Exception e)
                {
                    //e.printStackTrace();
                }
            }
        }
    }
}