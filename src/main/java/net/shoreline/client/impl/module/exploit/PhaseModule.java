package net.shoreline.client.impl.module.exploit;

import net.minecraft.block.BlockState;
import net.minecraft.block.ScaffoldingBlock;
import net.minecraft.entity.Entity;
import net.minecraft.entity.decoration.ItemFrameEntity;
import net.minecraft.item.EnderPearlItem;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.HandSwingC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerInteractEntityC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerInteractItemC2SPacket;
import net.minecraft.screen.slot.SlotActionType;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.*;
import net.minecraft.util.shape.VoxelShapes;
import net.shoreline.client.api.config.Config;
import net.shoreline.client.api.config.setting.BooleanConfig;
import net.shoreline.client.api.config.setting.EnumConfig;
import net.shoreline.client.api.config.setting.NumberConfig;
import net.shoreline.client.api.module.ModuleCategory;
import net.shoreline.client.impl.event.TickEvent;
import net.shoreline.client.impl.event.network.PlayerUpdateEvent;
import net.shoreline.client.impl.event.network.PushOutOfBlocksEvent;
import net.shoreline.client.impl.event.world.BlockCollisionEvent;
import net.shoreline.client.impl.module.ObsidianPlacerModule;
import net.shoreline.client.init.Managers;
import net.shoreline.client.util.player.RayCastUtil;
import net.shoreline.client.util.player.RotationUtil;
import net.shoreline.client.util.string.EnumFormatter;
import net.shoreline.eventbus.annotation.EventListener;
import net.shoreline.eventbus.event.StageEvent;

/**
 * @author linus
 * @since 1.0
 */
public class PhaseModule extends ObsidianPlacerModule
{
    private static PhaseModule INSTANCE;

    //
    Config<PhaseMode> modeConfig = register(new EnumConfig<>("Mode", "The phase mode for clipping into blocks", PhaseMode.NORMAL, PhaseMode.values()));
    Config<Integer> pitchConfig = register(new NumberConfig<>("Pitch", "The pitch to throw pearls", 70, 85, 90, () -> modeConfig.getValue() == PhaseMode.PEARL));
    Config<Boolean> swapAltConfig = register(new BooleanConfig("SwapAlternative", "Uses inventory swap for swapping to pearls", true, () -> modeConfig.getValue() == PhaseMode.PEARL));
    Config<Boolean> attackConfig = register(new BooleanConfig("Attack", "Attacks entities in the way of the pearl phase", false, () -> modeConfig.getValue() == PhaseMode.PEARL));
    Config<Boolean> raytraceConfig = register(new BooleanConfig("Raytrace", "Checks the landing position of the pearl", false, () -> modeConfig.getValue() == PhaseMode.PEARL));
    Config<Boolean> swingConfig = register(new BooleanConfig("Swing", "Swings the hand when throwing pearls", true, () -> modeConfig.getValue() == PhaseMode.PEARL));
    Config<Boolean> selfFillConfig = register(new BooleanConfig("SelfFill", "Automatically fills blocks you are phasing on", false, () -> modeConfig.getValue() == PhaseMode.PEARL));

    Config<Float> blocksConfig = register(new NumberConfig<>("Blocks", "The blocks distance to phase clip", 0.001f, 0.003f, 10.0f, () -> modeConfig.getValue() != PhaseMode.PEARL && modeConfig.getValue() != PhaseMode.CLIP));
    Config<Float> distanceConfig = register(new NumberConfig<>("Distance", "The distance to phase", 0.0f, 0.2f, 10.0f, () -> modeConfig.getValue() != PhaseMode.PEARL && modeConfig.getValue() != PhaseMode.CLIP));
    Config<Boolean> autoClipConfig = register(new BooleanConfig("AutoClip", "Automatically clips into the block", true, () -> modeConfig.getValue() != PhaseMode.PEARL && modeConfig.getValue() != PhaseMode.CLIP));

    /**
     *
     */
    public PhaseModule()
    {
        super("Phase", "Allows player to phase through solid blocks", ModuleCategory.EXPLOITS, 1000);
        unregister(multitaskConfig);
        INSTANCE = this;
    }

    public static PhaseModule getInstance()
    {
        return INSTANCE;
    }

    @Override
    public String getModuleData()
    {
        return EnumFormatter.formatEnum(modeConfig.getValue());
    }

    @Override
    public void onEnable()
    {
        if (mc.player == null)
        {
            return;
        }

        if (modeConfig.getValue() == PhaseMode.PEARL)
        {
            int pearlSlot = -1;
            for (int i = 0; i < 45; i++)
            {
                ItemStack stack = mc.player.getInventory().getStack(i);
                if (stack.getItem() instanceof EnderPearlItem)
                {
                    pearlSlot = i;
                    break;
                }
            }

            if (pearlSlot == -1 || mc.player.getItemCooldownManager().isCoolingDown(Items.ENDER_PEARL))
            {
                disable();
                return;
            }

            float prevYaw = mc.player.getYaw();
            float prevPitch = mc.player.getPitch();
            final Vec3d pearlTargetVec = new Vec3d(Math.floor(mc.player.getX()) + 0.5, 0.0, Math.floor(mc.player.getZ()) + 0.5);
            float[] rotations = RotationUtil.getRotationsTo(mc.player.getEyePos(), pearlTargetVec);
            float yaw = rotations[0] + 180.0f;  // normalize

            if (attackConfig.getValue())
            {
                BlockHitResult hitResult = (BlockHitResult) RayCastUtil.rayCast(3.0, new float[] { yaw, 60.0f });
                for (Entity entity : mc.world.getOtherEntities(null, new Box(hitResult.getBlockPos()).expand(0.2)))
                {
                    if (entity instanceof ItemFrameEntity itemFrameEntity)
                    {
                        if (!itemFrameEntity.getHeldItemStack().isEmpty())
                        {
                            Managers.NETWORK.sendPacket(PlayerInteractEntityC2SPacket.attack(entity, mc.player.isSneaking()));
                        }
                        Managers.NETWORK.sendPacket(PlayerInteractEntityC2SPacket.attack(entity, mc.player.isSneaking()));
                        Managers.NETWORK.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
                    }
                }

                BlockState state = mc.world.getBlockState(mc.player.getBlockPos());
                if (state.getBlock() instanceof ScaffoldingBlock)
                {
                    Managers.NETWORK.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, mc.player.getBlockPos(), Direction.UP));
                    Managers.NETWORK.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.STOP_DESTROY_BLOCK, mc.player.getBlockPos(), Direction.UP));
                }
            }

            if (selfFillConfig.getValue())
            {
                float yaw1 = yaw % 360.0f;
                if (yaw1 < 0.0f)
                {
                    yaw1 += 360.0f;
                }

                BlockPos blockPos = mc.player.getBlockPos();
                if (yaw1 >= 22.5 && yaw1 < 67.5)
                {
                    blockPos = blockPos.south().west();
                }
                else if (yaw1 >= 67.5 && yaw1 < 112.5)
                {
                    blockPos = blockPos.west();
                }
                else if (yaw1 >= 112.5 && yaw1 < 157.5)
                {
                    blockPos = blockPos.north().west();
                }
                else if (yaw1 >= 157.5 && yaw1 < 202.5)
                {
                    blockPos = blockPos.north();
                }
                else if (yaw1 >= 202.5 && yaw1 < 247.5)
                {
                    blockPos = blockPos.north().east();
                }
                else if (yaw1 >= 247.5 && yaw1 < 292.5)
                {
                    blockPos = blockPos.east();
                }
                else if (yaw1 >= 292.5 && yaw1 < 337.5)
                {
                    blockPos = blockPos.south().east();
                }
                else
                {
                    blockPos = blockPos.south();
                }

                int slot = getResistantBlockItem();
                if (slot != -1 && blockPos != null && !mc.world.getBlockState(blockPos.down()).isReplaceable())
                {
                    Managers.INTERACT.placeBlock(blockPos, slot,
                            strictDirectionConfig.getValue(), false, true, (state, angles) ->
                            {
                                if (state)
                                {
                                    Managers.ROTATION.setRotationSilent(angles[0], angles[1]);
                                }
                                else
                                {
                                    Managers.ROTATION.setRotationSilentSync();
                                }
                            });
                }
            }

            setRotationClient(yaw, pitchConfig.getValue());
            // mc.player.networkHandler.sendPacket(new PlayerMoveC2SPacket.LookAndOnGround(rotations[0] + 180.0f, pitchConfig.getValue(), mc.player.isOnGround()));
            if (swapAltConfig.getValue())
            {
                mc.interactionManager.clickSlot(0, pearlSlot < 9 ? pearlSlot + 36 : pearlSlot, 0, SlotActionType.PICKUP, mc.player);
                mc.interactionManager.clickSlot(0, mc.player.getInventory().selectedSlot + 36, 0, SlotActionType.PICKUP, mc.player);
                mc.interactionManager.clickSlot(0, pearlSlot < 9 ? pearlSlot + 36 : pearlSlot, 0, SlotActionType.PICKUP, mc.player);
            }
            else if (pearlSlot < 9)
            {
                Managers.INVENTORY.setSlot(pearlSlot);
            }

            setRotationSilent(yaw, pitchConfig.getValue());
            Managers.NETWORK.sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id, yaw, pitchConfig.getValue()));
            Managers.PEARL.setLastThrownAngles(new float[] { yaw, pitchConfig.getValue() });
            if (swingConfig.getValue())
            {
                mc.player.swingHand(Hand.MAIN_HAND);
            }
            else
            {
                Managers.NETWORK.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
            }

            if (swapAltConfig.getValue())
            {
                mc.interactionManager.clickSlot(0, pearlSlot < 9 ? pearlSlot + 36 : pearlSlot, 0, SlotActionType.PICKUP, mc.player);
                mc.interactionManager.clickSlot(0, mc.player.getInventory().selectedSlot + 36, 0, SlotActionType.PICKUP, mc.player);
                mc.interactionManager.clickSlot(0, pearlSlot < 9 ? pearlSlot + 36 : pearlSlot, 0, SlotActionType.PICKUP, mc.player);
            }
            else if (pearlSlot < 9)
            {
                Managers.INVENTORY.syncToClient();
            }

            Managers.ROTATION.setRotationSilentSync();
            setRotationClient(prevYaw, prevPitch);
            disable();
        }

        else if (autoClipConfig.getValue())
        {
            double cos = Math.cos(Math.toRadians(mc.player.getYaw() + 90.0f));
            double sin = Math.sin(Math.toRadians(mc.player.getYaw() + 90.0f));
            mc.player.setPosition(mc.player.getX() + (1.0 * blocksConfig.getValue() * cos + 0.0 * blocksConfig.getValue() * sin),
                    mc.player.getY(), mc.player.getZ() + (1.0 * blocksConfig.getValue() * sin - 0.0 * blocksConfig.getValue() * cos));
        }
    }

    @EventListener
    public void onTick(TickEvent event)
    {
        if (event.getStage() != StageEvent.EventStage.PRE || modeConfig.getValue() != PhaseMode.CLIP
                || !mc.player.isOnGround() || mc.player.isRiding())
        {
            return;
        }

        // fucks with mc hitbox checks
        Vec3d vec3d = mc.player.getBlockPos().toCenterPos();
        boolean flagX = (vec3d.x - mc.player.getX()) > 0;
        boolean flagZ = (vec3d.z - mc.player.getZ()) > 0;
        double x = vec3d.x + 0.20000000009497754 * (flagX ? -1 : 1);
        double z = vec3d.z + 0.2000000000949811 * (flagZ ? -1 : 1);
        mc.player.setPosition(x, mc.player.getY(), z);
        disable();
    }

    @EventListener
    public void onBlockCollision(BlockCollisionEvent event)
    {
        if (mc.player == null)
        {
            return;
        }
        switch (modeConfig.getValue())
        {
            case NORMAL ->
            {
                if (event.getVoxelShape() != VoxelShapes.empty() && event.getVoxelShape().getBoundingBox().maxY > mc.player.getBoundingBox().minY && mc.player.isSneaking())
                {
                    event.cancel();
                    event.setVoxelShape(VoxelShapes.empty());
                }
            }
            case SAND ->
            {
                event.cancel();
                event.setVoxelShape(VoxelShapes.empty());
                mc.player.noClip = true;
            }
            case CLIMB ->
            {
                if (mc.player.horizontalCollision)
                {
                    event.cancel();
                    event.setVoxelShape(VoxelShapes.empty());
                }
                if (mc.player.input.sneaking || (mc.player.input.jumping
                        && event.getPos().getY() > mc.player.getY()))
                {
                    event.cancel();
                }
            }
        }
    }

    @EventListener
    public void onPlayerUpdate(PlayerUpdateEvent event)
    {
        switch (modeConfig.getValue())
        {
            case NORMAL ->
            {
                if (mc.player.isSneaking() && isPhasing())
                {
                    float yaw = mc.player.getYaw();
                    mc.player.setBoundingBox(mc.player.getBoundingBox().offset(
                            distanceConfig.getValue() * Math.cos(Math.toRadians(yaw + 90.0f)),
                            0.0, distanceConfig.getValue() * Math.sin(Math.toRadians(yaw + 90.0f))));
                }
            }
            case SAND ->
            {
                Managers.MOVEMENT.setMotionY(0.0);
                if (mc.isWindowFocused())
                {
                    if (mc.player.input.jumping)
                    {
                        Managers.MOVEMENT.setMotionY(mc.player.getVelocity().y + 0.3);
                    }
                    if (mc.player.input.sneaking)
                    {
                        Managers.MOVEMENT.setMotionY(mc.player.getVelocity().y - 0.3);
                    }
                }
                mc.player.noClip = true;
            }
        }
    }

    @EventListener
    public void onPushOutOfBlocks(PushOutOfBlocksEvent event)
    {
        event.cancel();
    }

    public boolean isPhasing()
    {
        Box bb = mc.player.getBoundingBox();
        for (int x = MathHelper.floor(bb.minX); x < MathHelper.floor(bb.maxX) + 1; x++)
        {
            for (int y = MathHelper.floor(bb.minY); y < MathHelper.floor(bb.maxY) + 1; y++)
            {
                for (int z = MathHelper.floor(bb.minZ); z < MathHelper.floor(bb.maxZ) + 1; z++)
                {
                    if (mc.world.getBlockState(new BlockPos(x, y, z)).blocksMovement())
                    {
                        if (bb.intersects(new Box(x, y, z, x + 1.0, y + 1.0, z + 1.0)))
                        {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    public boolean shouldRaytrace()
    {
        return raytraceConfig.getValue();
    }

    public enum PhaseMode
    {
        NORMAL,
        SAND,
        CLIMB,
        PEARL,
        CLIP
    }
}
